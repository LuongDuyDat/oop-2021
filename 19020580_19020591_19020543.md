**_So sánh giữa 23 mẫu thiết kế của youlookwhat với 23 mẫu thiết kế kinh điển của GOF_**

# I. Creational:

## 1. Singleton:

### Giống:

**Đều sử dụng `ba bước` để đảm bảo tính duy nhất của đối tượng:**

1. Các chương trình khác không được phép sử dụng đối tượng mới.
2. Tạo các đối tượng trong lớp này.
3. Cung cấp một phương thức để các chương trình khác lấy được đối tượng.

**Định nghĩa so sánh:**

1. Tư nhân hóa hàm tạo của lớp.
2. Tạo một đối tượng của lớp này trong lớp này thông qua “new”.
3. Định nghĩa một phương thức công khai để trả về các đối tượng được tạo trong lớp này.

### Khác:

Singleton kiểu danh mục nội bộ (Inner class)

```java
public class SingletonIn {
    private SingletonIn() {
    }
    private static class SingletonInHolder {
        private static SingletonIn singletonIn = new SingletonIn();
    }
    public static SingletonIn getSingletonIn() {
        return SingletonInHolder.singletonIn;
    }
}
```

> Điểm đặc biệt của kiểu Trung Quốc là miễn là lớp Singleton được tải, nó sẽ được khởi tạo, không có tác dụng của Lazy-Loading và phương thức lớp bên trong tĩnh là khi lớp Singleton được tải.

> Nó sẽ không được khởi tạo ngay lập tức, nhưng khi cần khởi tạo, phương thức getInstance sẽ được gọi để tải lớp SingletonHolder để hoàn thành việc khởi tạo Singleton.

> Các thuộc tính tĩnh của lớp sẽ chỉ được khởi tạo khi lớp được tải lần đầu tiên, vì vậy ở đây, JVM giúp chúng ta đảm bảo an toàn cho luồng. Khi lớp được khởi tạo, các luồng khác sẽ không thể tiếp cận được.

> Ưu điểm: tránh mất an toàn luồng, tải chậm và hiệu quả cao.

## 2. Factory/Abstract Factory:

### Giống:

- Xác định giao diện để tạo một đối tượng, nhưng hãy để các lớp con quyết định lớp nào sẽ khởi tạo. Phương thức Nhà máy cho phép một lớp trì hoãn việc khởi tạo thành các lớp con.
- Ngoài ra, ở mẫu `Abstract Factory` còn cung cấp một giao diện để tạo họ các đối tượng liên quan hoặc phụ thuộc mà không chỉ định các lớp cụ thể của chúng.

### Khác:

**Rút gọn các họ của mẫu này:**

1. Chế độ nhà máy tĩnh
   Đây là lớp bổ trợ, phổ biến nhất trong dự án, TextUtil.isEmpty, v.v., lớp + phương thức tĩnh.

2. Mô hình nhà máy đơn giản
   Định nghĩa: Nó chịu trách nhiệm tạo các thể hiện của các lớp khác bằng cách xác định cụ thể một lớp Các thể hiện được tạo thường có một lớp cha chung.

```java
public class SimpleRoujiaMoFactory {
    public RoujiaMo creatRoujiaMo(String type) {
        RoujiaMo roujiaMo = null;
        switch (type) {
            case "Suan":
                roujiaMo = new ZSuanRoujiaMo();
                break;
            case "La":
                roujiaMo = new ZLaRoujiaMo();
                break;
            case "Tian":
                roujiaMo = new ZTianRoujiaMo();
                break;
            default:
                roujiaMo = new ZSuanRoujiaMo();
                break;
        }
        return roujiaMo;
    }
}
```

Trên đây là mô hình một nhà máy đơn giản sản xuất bánh mì kẹp Tây An.

3. Mô hình phương pháp nhà máy
   **`Định nghĩa:`** Định nghĩa một giao diện để tạo các đối tượng, nhưng lớp con quyết định lớp nào để khởi tạo. Mẫu phương thức gốc định nghĩa quá trình khởi tạo lớp thành các lớp con.
   **`Định nghĩa so sánh:`**

   - Một giao diện để tạo các đối tượng được định nghĩa: public abstract RouJiaMo sellRoujiaMo (String type);
   - Lớp được khởi tạo được xác định bởi lớp con và chúng ta có thể thấy rằng bánh mì của chúng ta được tạo bởi lớp con.

4. Mô hình nhà máy trừu tượng
   **`Định nghĩa:`** Cung cấp giao diện để tạo họ các đối tượng liên quan hoặc phụ thuộc mà không cần chỉ định các lớp cụ thể.
   **Ví dụ:** Tạo 1 giao diện mới để cung cấp nguyên liệu thô làm bánh mì Tân An.

```java
public interface RoujiaMoYLFactory {
    /**
     * 生产肉
     */
    public Meet creatMeet();

    /**
     * 生产一些原料
     */
    public YuanLiao creatYuanLiao();
}
```

```java
public class XianRoujiaMoYLFoctory implements RoujiaMoYLFactory {

    @Override
    public Meet creatMeet() {
        return new XianFreshMeet();
    }

    @Override
    public YuanLiao creatYuanLiao() {
        return new XianTeSeYuanLiao();
    }
}
```

_Sau sửa đổi lại phương pháp chuẩn bị bánh mì:_

```java
public abstract class RoujiaMo {

    protected String name;
    /**
     * 准备工作
     */
    public void prepare(RoujiaMoYLFactory roujiaMoYLFactory) {
        Meet meet = roujiaMoYLFactory.creatMeet();
        YuanLiao yuanLiao = roujiaMoYLFactory.creatYuanLiao();

        Log.e("---RoujiaMo:", "使用官方的原料 ---" + name + ": 揉面-剁肉-完成准备工作 yuanLiao:"+meet+"yuanLiao:"+yuanLiao);
    }
    /**
     * 秘制设备--烘烤2分钟
     */
    public void fire() {
        Log.e("---RoujiaMo:", name + ": 肉夹馍-专用设备-烘烤");
    }
    /**
     * 使用你们的专用袋-包装
     */
    public void pack() {
        Log.e("---RoujiaMo:", name + ": 肉夹馍-专用袋-包装---end");
    }
}
```

**`So sánh các định nghĩa:`**

1. Cung cấp giao diện: giao diện công khai `RouJiaMoYLFactroy`
2. Được sử dụng để tạo một họ các đối tượng liên quan hoặc phụ thuộc `public Meat createMeat ();` `public YuanLiao createYuanliao ();` Giao diện của tác giả được sử dụng để tạo một loạt các nguyên liệu thô.

## 3. Builder:

### Giống:

**`Tổng quan:`** Tách construction một đối tượng phức tạp khỏi biểu diễn của nó để các construction giống nhau có thể tạo ra các biểu diễn khác nhau.

- Ràng buộc bởi `4` yếu tố chính:
  - `Danh mục sản phẩm`: Nói chung, nó là một object phức tạp hơn, có nghĩa là quá trình tạo một object phức tạp hơn và nhìn chung sẽ có một lượng code lớn hơn. Trong sơ đồ lớp này, lớp sản phẩm là một lớp cụ thể, không phải là một lớp trừu tượng. Trong lập trình thực tế, một lớp sản phẩm có thể bao gồm một lớp trừu tượng và các cách triển khai khác nhau của nó, hoặc nó có thể bao gồm nhiều lớp trừu tượng và các triển khai của chúng.
  - `Trình xây dựng trừu tượng`: Mục đích của việc giới thiệu trình xây dựng trừu tượng là chuyển giao quá trình xây dựng cụ thể cho các lớp con của nó để đạt được. Điều này làm cho nó dễ dàng mở rộng hơn. Nói chung, có ít nhất hai phương pháp trừu tượng, một để xây dựng sản phẩm và một để trả lại sản phẩm.
  - `Builder`: Để triển khai tất cả các phương thức chưa hoàn thành của lớp trừu tượng. Cụ thể, chung quy là hai nhiệm vụ: xây dựng một sản phẩm; trả lại sản phẩm đã xây dựng.
  - `Lớp Director (Giám đốc)`: Chịu trách nhiệm gọi Builder phù hợp để xây dựng sản phẩm. Lớp `Director` nói chung không có mối quan hệ phụ thuộc với lớp sản phẩm. Đây là lớp `Builder` tương tác trực tiếp với lớp `Director`. Nói chung, lớp `Director` được sử dụng để đóng gói các phần có thể thay đổi của chương trình.
- Mô hình mẫu:

```java
class Product {
        private String name;
        private String type;
        public void showProduct(){
            System.out.println("名称："+name);
            System.out.println("型号："+type);
        }
        public void setName(String name) {
            this.name = name;
        }
        public void setType(String type) {
            this.type = type;
        }
    }

    abstract class Builder {
        public abstract void setPart(String arg1, String arg2);
        public abstract Product getProduct();
    }
    class ConcreteBuilder extends Builder {
        private Product product = new Product();

        public Product getProduct() {
            return product;
        }

        public void setPart(String arg1, String arg2) {
            product.setName(arg1);
            product.setType(arg2);
        }
    }

    public class Director {
        private Builder builder = new ConcreteBuilder();
        public Product getAProduct(){
            builder.setPart("宝马汽车","X7");
            return builder.getProduct();
        }
        public Product getBProduct(){
            builder.setPart("奥迪汽车","Q5");
            return builder.getProduct();
        }
    }
    public class Client {
        public static void main(String[] args){
            Director director = new Director();
            Product product1 = director.getAProduct();
            product1.showProduct();

            Product product2 = director.getBProduct();
            product2.showProduct();
        }
    }
```

### Khác

_Về cơ bản, cách tiếp cận của youlookwhat không có khác biệt đối với cách kinh điển của GOF._
